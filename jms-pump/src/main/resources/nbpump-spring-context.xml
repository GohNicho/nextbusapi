<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     
       xmlns:int="http://www.springframework.org/schema/integration"
       xmlns:jms="http://www.springframework.org/schema/integration/jms"  
       xmlns:task="http://www.springframework.org/schema/task"
       xmlns:bean="http://www.springframework.org/schema/beans"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="
       http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-2.1.xsd
       http://www.springframework.org/schema/integration/jms http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd
       http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd">

    <!-- Configuration for everything comes from a Properties file in the run classpath -->
    <bean id="nbpumper" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="file:nbpumper.properties"/>
    </bean>
    
    <!-- Spring Integration wants a Task Schedule/Runner to execute our timed task... -->
    <task:scheduler id="taskScheduler"  pool-size="1" />
    <task:executor id="dfltExecutor" pool-size="1"/>
       
    <!-- This is the generic NextBus XML Adapter -->
    <bean id="nextbusProtocolAdapter" class="net.sf.nextbus.publicxmlfeed.impl.SimplestNextbusServiceAdapter" lazy-init="false"/>
    
    <!-- This is the Task Master, it gets called by the Spring Scheduler to sweep new information from NextBus -->
    <bean id="nextBusHarvester" class="net.sf.nextbus.jmspump.sender.Task">
        <constructor-arg  ref="nextbusProtocolAdapter"/>
        <constructor-arg value="${nbpumper.agency}"/>
        <constructor-arg value="${nbpumper.routes}"/>
        <property name="refreshInterval" value="${nbpumper.refreshtime}"/>
        <property name="maxNextbusCallsPerExecution" value="${nbpumper.maxrpcs-per-poll}"/>
    </bean>
    
    <!-- **************** Spring Integration Section **************** -->
    <!-- Declare an Error Channel and simply sent all events to log4j -->
    <int:channel id="errorChannel" /> 
    <int:logging-channel-adapter channel="errorChannel"  id="logger" log-full-message="true" level="ERROR"/>
      
    <!-- 
        Declare an Input Channel sourced from a Generic POJO adapter and driven by a Time Task. 
    -->
    <int:channel id="nextbus"/> 
    <int:inbound-channel-adapter id="adapter1" ref="nextBusHarvester" method="execute" channel="nextbus">
        <int:poller fixed-rate="${nbpumper.pollrate}" task-executor="dfltExecutor"/>
    </int:inbound-channel-adapter>  
    
    <!-- 
        Use a Splitter to disassemble a Message containing List<VehLocn> into N atomic messages of VehLocn
     -->
    <int:channel id="nextbus-split" datatype="net.sf.nextbus.publicxmlfeed.domain.VehicleLocation" />
    <bean id="vlsplitter" class="org.springframework.integration.splitter.DefaultMessageSplitter"/>
    <int:splitter input-channel="nextbus" output-channel="nextbus-split"/>
       
    <!--
        Use a Header Enricher to set JMS Header Values so that Subscriber can use Message Selection criteria
    -->
    <!-- Attemps to use Spring Expr. Language to manipulate more than 1 payload property caused problems... Resorted to a helper bean.-->
    <bean id="vlheaderenricher" class="net.sf.nextbus.jmspump.msgtools.VLMessageHeaderEnricher"/>
    <int:header-enricher input-channel="nextbus-split" output-channel="nextbus-split">
        <int:header name="JMSType" value="VehicleLocation" />
        <int:header name="agencyId" ref="vlheaderenricher" method="getAgencyId" />
        <int:header name="routeId" ref="vlheaderenricher" method="getRouteId" />
        <int:header name="vehicleId" ref="vlheaderenricher" method="getVehicleId" />
        <int:header name="longitude" ref="vlheaderenricher" method="getLongitude" />
        <int:header name="latitude" ref="vlheaderenricher" method="getLatitude" />
        <int:header name="timestamp" ref="vlheaderenricher" method="getTimestamp" />
        <int:header name="copyrightNotice" ref="vlheaderenricher" method="getCopyrightNotice" />
    </int:header-enricher>
   
    <!-- 
        Create an Output Channel that simply feeds a JMS Queue or Topic
    -->
    <jms:outbound-channel-adapter id="adapter2" channel="nextbus-split" 
                                  destination="${nbpumper.sender_type}" 
                                  connection-factory="cachedJmsConnectionFactory" 
                                  time-to-live="${nbpumper.jms.ttl}" />
    
    <!-- 
        The cached connection factory improves client send performance by avoiding JMS Connection setup/teardown for each connection.
        This simply layers ontop of an ActiveMQ Connection Factory - see activemq-jms_config.xml for more details
     -->
        
    <bean id="cachedJmsConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory" lazy-init="false">
        <property name="sessionCacheSize" value="1"/> 
        <property name="reconnectOnException" value="true"/>
        <property name="targetConnectionFactory" ref="amq_connectionFactory" /> <!-- Change here to glassfish, amq, jboss, etc -->   
    </bean>
</beans>