<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     
       xmlns:int="http://www.springframework.org/schema/integration"
       xmlns:jms="http://www.springframework.org/schema/integration/jms"  
       xmlns:task="http://www.springframework.org/schema/task"
       xmlns:bean="http://www.springframework.org/schema/beans"
       xmlns:stream="http://www.springframework.org/schema/integration/stream"
       xsi:schemaLocation="
       http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-2.1.xsd
       http://www.springframework.org/schema/integration/jms http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd
       http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-1.0.xsd">

    <!-- Configuration for everything comes from a Properties file in the run classpath f-->
    <bean id="nbpumper" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="file:nbpumper.properties"/>
    </bean>
    
    <!-- Spring Integration wants a Task Schedule/Runner for to execute our timed task... -->
    <task:scheduler id="taskScheduler" pool-size="1"/>
    <task:executor id="dfltExecutor" pool-size="1"/>

    
    <!-- This is the generic NextBus XML Adapter -->
    <bean id="nextbusProtocolAdapter" class="net.sf.nextbus.publicxmlfeed.impl.SimplestNextbusServiceAdapter" lazy-init="false"/>
    
    <!-- This is the Task Master, it gets called by the Spring Schedule to sweep new information from NextBus -->
    <bean id="nextBusHarvester" class="net.sf.nextbus.jmspump.sender.Task">
        <constructor-arg  ref="nextbusProtocolAdapter"/>
        <constructor-arg value="${nbpumper.agency}"/>
        <constructor-arg value="${nbpumper.routes}"/>
        <property name="refreshInterval" value="${nbpumper.refreshtime}"/>
    </bean>
    
    <!-- Spring Integration: Declare an errorChannel and simple sent it out to log4j -->
     <int:channel id="errorChannel" /> 
     <int:logging-channel-adapter channel="errorChannel"  id="logger" log-full-message="true" level="ERROR"/>
      
    <!-- 
        The input channel is driven by a generic Spring POJO adapter that drives the NextBus XML harvester on a schedule. 
         We poll it every second, but fresh data might only come every 5 minutes on particular bus routes. 
         Why the 5 minute delay?  We dont want to clobber the NextBus service endpoint with tons of frequent requests.
    -->
    <int:channel id="nextbus"/> 
    
    <int:inbound-channel-adapter id="adapter1" ref="nextBusHarvester" method="execute" channel="nextbus">
        <int:poller fixed-rate="1000" task-executor="dfltExecutor"/>
    </int:inbound-channel-adapter>  
    
    <!-- The Harvester produces a Message with a List<Veh..Loc8n> - we need to split this List into indiv. objects! -->
    <int:channel id="nextbus-split" datatype="net.sf.nextbus.publicxmlfeed.domain.VehicleLocation" />
    <bean id="vlsplitter" class="org.springframework.integration.splitter.DefaultMessageSplitter"/>
    <int:splitter input-channel="nextbus" output-channel="nextbus-split"/>
       
    <!-- The header enricher simply extracts some facts from the Location POJO that is useful to JMS Message Selection.. -->
    <!-- Attemps to use Spring Expr. Language to manipulate more than 1 payload property caused problems... Resorted to a helper bean.-->
    <bean id="vlheaderenricher" class="net.sf.nextbus.jmspump.msgtools.VLMessageHeaderEnricher"/>
    <int:header-enricher input-channel="nextbus-split" output-channel="nextbus-split">
        <int:header name="JMSType" value="VehicleLocation" />
        <int:header name="agencyId" ref="vlheaderenricher" method="getAgencyId" />
        <int:header name="routeId" ref="vlheaderenricher" method="getRouteId" />
        <int:header name="vehicleId" ref="vlheaderenricher" method="getVehicleId" />
        <int:header name="longitude" ref="vlheaderenricher" method="getLongitude" />
        <int:header name="latitude" ref="vlheaderenricher" method="getLatitude" />
        <int:header name="timestamp" ref="vlheaderenricher" method="getTimestamp" />
    </int:header-enricher>
   
    <!-- 
        The output channel is a JMS Topic, doesn't matter which Vendor either.  The specific provisioning is in a /resources/$vendor-jms-config.xml file. 
    -->
    <jms:outbound-channel-adapter id="adapter2" channel="nextbus-split" 
         destination="${nbpumper.sender_type}" 
         connection-factory="amq_connectionFactory" 
         time-to-live="${nbpumper.jms.ttl}" />
    
    <!-- The cached connection factory improves client send performance by avoiding JMS Connection setup/teardown for each connection. -->
    <bean id="cachedJmsConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory" lazy-init="false">
        <property name="sessionCacheSize" value="1"/> 
        <property name="reconnectOnException" value="true"/>
        <property name="targetConnectionFactory" ref="amq_connectionFactory" /> <!-- Change here to glassfish, amq, jboss, etc -->
       
   </bean>
</beans>